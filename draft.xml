<?xml version="1.0" encoding="utf-8"?>
<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  submissionType="IETF"
  category="std"
  ipr="trust200902">
  <front>
    <title>OAuth 2.0 Multi-Factor Authorization</title>
    <seriesInfo name="Internet-Draft" value="draft-hanson-oauth-mfa-00"/>
    <author fullname="Jared Hanson" initials="J." surname="Hanson" >
      <organization>Okta</organization>
      <address>
        <postal>
          <street>100 First Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94105</code>
          <country>US</country>
        </postal>
        <email>jared.hanson@okta.com</email>
        <uri>https://www.jaredhanson.me/</uri>
      </address>
    </author>
    <date/>
    <area>Security</area>
    <workgroup>Web Authorization Protocol</workgroup>
    
    <abstract>
      <t>This specification provides a framework for the use of strong
        authorization with OAuth 2.0.  Mechanisms are specified for initiating
        an authorization session.  New authorization grant types are defined
        that allow clients to obtain access tokens within the context of a
        strongly authorized session.</t>
    </abstract>
  </front>
  <middle>
    
    <section title="Introduction">
      <t>Strong authorization is a method of access control that grants access
        only after multiple factors of authentication and/or authorization have
        been presented.  Authentication factors typically fall into the
        following categories: knowledge (something you know), possession
        (something you have), and inherence (something you are).  Strong
        authorization factors include transaction confirmation and multi-party
        authorization.</t>
      
      <t>OAuth 2.0 <xref target="RFC6749"/> is an authorization framework that
        enables a third-party application to obtain limited access to a
        protected HTTP resource. In OAuth, those third-party applications are
        called clients; they access protected resources by presenting an access
        token to the HTTP resource.  Access tokens are issued to clients by an
        authorization server with the (sometimes implicit) approval of the
        resource owner. These access tokens are typically obtained by exchanging
        an authorization grant, which represents the authorization granted by
        the resource owner (or by a privileged administrator).</t>
        
      <t>This specification defines a general framework for the use of strong
        authorization within OAuth 2.0.  It provides a mechanism for indicating
        when strong authorization is required.  It also provides a generic
        mechanism for obtaining a strong authorization challenge.  It defines
        additional extension grant types that allow strong authorization grants
        to be presented in order to obtain access tokens.</t>
      
      <t>This use of strong authorization allows authorization servers to
        implement correspondingly strong authorization policies, including
        step-up authentication and transaction confirmation.</t>
        
      <t>Authorization servers that implement support for resource owner
        password credentials can augment existing password infrastructure by
        requiring a strong second factor of authentication prior to issuing
        access tokens.</t>
        
      <t>Transaction confirmation can be used to increase the level of assurance
        prior to issuing tokens for highly privileged operations, such as a bank
        withdrawl.  For example, an end-user (resource owner) can grant an
        application (client) access to her account at a brokerage firm (resource
        server).  The application is authorized to obtain real-time stock quotes
        as well as place orders, and is issued both an access token and refresh
        token.  As a matter of policy, the access token can be used to obtain
        stock quotes and is valid for 24 hours.  Every 24 hour period, the
        refresh token is used to obtain a new access token, so that access to
        stock quotes is uninterrupted.  The access token can also be used to
        place an order, but is subject to more stringent security requirements.
        Using this extension, the refresh token can be used to initiate an
        authorization session which, once confirmed by the user, allows issuance
        of an access token that demonstrates strong authentication and has a
        limited lifetime.</t>
        
        <section title="Notational Conventions">
          <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
            "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
            "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
        </section>
        
      <section>
        <name>Terminology</name>
        
        <t>This specification also defines the following terms:</t>
        
        <dl newline="true">
          <dt>Authorization Challenge</dt>
          <dd>A challenge issued by an authorization server to a client
            requesting an additional authorization grant that is required in
            order to issue an access token.</dd>
            
          <dt>Authorization Session</dt>
          <dd>A sequence of access token requests to the token endpoint, each
            presenting an authorization grant.  The sequence MAY involve
            requests to additional endpoints, as needed by specific grant
            types.</dd>
          
          <dt>MFA Token</dt>
          <dd>A short lived token representing an authorization session, used
            to keep state during an authorization session.</dd>
        </dl>
      </section>
        
      <section>
        <name>Protocol Flow</name>
        
        <figure anchor="abstract-protocol-flow">
          <name>Abstract Protocol Flow</name>
          
          <artwork><![CDATA[
+-------------+
|  Resource   |
|    Owner    |
|             |
+-------------+
  |  ^   |  ^
  |  |   |  |
 (A)(B) (E)(F)
  |  |   |  |
  v  |   v  |
+-------------+                                     +---------------+
|             |--(C)--- Authorization Grant ------->|               |
|             |                                     |               |
|             |<-(D)- Authorization Challenge ------|               |
|             |                                     | Authorization |
|             |--(G)-- Additional Authz Grant ----->|    Server     |
|             |             & MFA Token             |               |
|             |                                     |               |
|   Client    |<-(H)------- Access Token -----------|               |
|             |                                     +---------------+
|             |
|             |                                     +---------------+
|             |--(I)------- Access Token ---------->|               |
|             |                                     |   Resource    |
|             |<-(J)---- Protected Resource --------|    Server     |
|             |                                     |               |
+-------------+                                     +---------------+
]]></artwork>
        </figure>
        
        <t>The abstract OAuth 2.0 multi-factor authorization flow illustrated
          in <xref target="abstract-protocol-flow"/> describes the interaction
          between the resource owner, client, authorization server, and
          resource server and includes the following steps:</t>
        
        <ol type='(%C)'>
          <li>The client requests authorization from the resource owner.  The
            authorization request can be made directly to the resource owner
            (as shown), or indirectly via the authorization server as an
            intermediary.</li>
          
          <li>The client receives an authorization grant, which is a
            credential representing the resource owner's authorization.  The
            authorization grant type depends on the method used by the client
            to request authorization and the types supported by the
            authorization server.</li>
          
          <li>The client requests an access token by authenticating with the
            authorization server and presenting the authorization grant.</li>
          
          <li>The authorization server authenticates the client and validates
            the authorization grant, and if an additional authorization grant
            is required, issues an authorization challenge.</li>
          
          <li>The client requests additional authorization from the resource
            owner.  The authorization request is made directly to the resource
            owner.</li>
          
          <li>The client receives an additional authorization grant.  The
            authorization grant type depends on the method used by the client
            to request authorization and the types supported by the
            authorization server.</li>
          
          <li>The client requests an access token by authenticating with the
            authorization server and presenting the additional authorization
            grant along with the MFA token received in the authorization
            challenge.</li>
          
          <li>The authorization server authenticates the client and validates
            the authorization grant and MFA token, and if both are valid,
            issues an access token.</li>
          
          <li>The client requests the protected resource from the resource
            server and authenticates by presenting the access token.</li>
          
          <li>The resource server validates the access token, and if valid,
            serves the request.</li>
        </ol>
      </section>
        
      <section>
        <name>Authorization Grants</name>
        
        <t>An authorization grant is a credential representing the resource
          owner's authorization (to access its protected resources) used by
          the client to obtain an access token.  This specification defines
          three grant types -- one-time password credentials, out-of-band, and
          recovery code -- that can be used as additional authorization grants
          within an authorization session.</t>
        
        <section>
          <name>One-Time Password Credentials</name>
          
          <t>The one-time password (OTP) credentials can be used as an
            authorization grant to obtain an access token.  An OTP is generated
            by a hardware device or a software application installed on a
            device such as a mobile phone.  These devices have an embedded
            secret which used as a seed for generating OTPs.  An OTP is
            single-use and proves control of the device.</t>
          
          <t>When used in addition to another grant type (such as resource owner
            password credentials), one-time password credentials add an
            additional factor of authentication.</t>
            
          <t>Even though this grant type requires direct client access to the
            resource owner credentials, the resource owner credentials are used
            for a single request and are exchanged for an access token.
            Furthermore, the single-use nature of an OTP limits the impact of
            exposing a long-term password alone to the client when the resulting
            access token or refresh token are also short-lived.</t>
        </section>
        
        <section>
          <name>Out-of-Band Authorization</name>
          
          <t>The out-of-band (OOB) authorization grant allows authorization to
            be obtained via a secondary channel.  Once authorized, the grant can
            be used to obtain an access token.  Use of a secondary channel
            supports several use cases.</t>
            
          <t>The out-of-band authorization grant can be used with an out-of-band
            authenticator to add an additional factor of authentication.  An
            out-of-band authenticator is a physical device that is uniquely
            addressable and can communicate with the authorization server over a
            secondary channel.  Common examples would be a mobile phone using
            SMS as a secondary channel, or a software application installed on a
            device using push notifications as a secondary channel.</t>
          
          <t>The out-of-band authorization grant can also facilitate more
            complex authorization processes.  For example, out-of-band
            authorization can be used to perform multi-party authorization, in
            which two or more resource owners are needed in order to grant
            access.</t>
        </section>
        
        <section>
          <name>Recovery Code</name>
          
          <t>The recovery code is numeric or character string from a set of
            secrets shared between the resource owner and the authorization
            server.  These secrets are typically used by the resource owner
            in the event another authenticator is lost or malfunctions.</t>
        </section>
      </section>
    </section>
    
    <section>
      <name>Protocol Endpoints</name>
      
      <t>
        The multi-factor authorization process utilizes two authorization server
        endpoints (HTTP resources):
      </t>
      
      <ul>
        <li>Token endpoint - used by the client to exchange an authorization
          grant for an access token, typically with client authentication.  This
          endpoint will be called multiple times within an authorization
          session.</li>
        
        <li>Authorization challenge endpoint - used by the client to obtain an
          authorization challenge, the response to which can be used as an
          authorization grant.</li>
      </ul>
      
      <t>Not every authorization grant type utilizes both endpoints.  Extension
        grant types MAY define additional endpoints as needed.</t>
      
      <section>
        <name>Token Endpoint</name>
        
        <t>The token endpoint is used by the client to obtain an access token by
          presenting its authorization grant or refresh token, as described in
          <xref target="RFC6749" section="3.2">OAuth 2.0</xref>.</t>
        
        <t>If the access token request is valid and authorized, the
          authorization server issues an access token and optional refresh token
          as described in <xref target="RFC6749" section="5.1">OAuth 2.0</xref>.
          If the request failed client authentication or is invalid, the
          authorization server returns an error response as described in
          <xref target="RFC6749" section="5.2">OAuth 2.0</xref>.</t>
          
        <t>If the access token request is valid but not sufficiently authorized,
          the authorization server MAY issue an authorization challenge error
          response as as described in
          <xref target="authorization-challenge-error-response"/>.</t>
        
        <section anchor="authorization-challenge-error-response">
          <name>Authorization Challenge Error Response</name>
          
          <t>An authorization challenge error response is a particular type of
            error response as defined in
            <xref target="RFC6749" section="5.2">OAuth 2.0</xref> where the
            error code is set to the following value:</t>
          
          <dl newline="true">
            <dt>mfa_required</dt>
            <dd>The authorization grant is insufficiently authorized, but
              another access token request MAY succeed if an additional
              authorization grant is presented.</dd>
          </dl>
          
          <t>In addition to the response parameters defined in
            <xref target="RFC6749" section="5.2">OAuth 2.0</xref>, the
            following parameters MUST be included in the response when the
            error code is set to <tt>"mfa_required"</tt>:</t>
          
          <dl newline="true">
            <dt>mfa_token</dt>
            <dd>MFA token value associated with the ongoing authorization
              session.</dd>
          </dl>
          
          <t>For example:</t>
          <figure>
            <artwork><![CDATA[
  HTTP/1.1 403 Forbidden
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "error":"mfa_required",
    "mfa_token": "eyJhbGciOiJIUzI1NiIsImtpZCI6IjFlOWdkazcifQ.eyJpc3Mi
      OiJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwic3ViIjoiMjQ4Mjg5NzYxMDA
      xIiwiYXVkIjpbImh0dHA6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20vdG9rZW4iLCJodH
      RwOi8vc2VydmVyLmV4YW1wbGUuY29tL2F1dGhlbnRpY2F0b3JzIl0sIm1mYSI6W
      yJvdHAiLCJvb2IiXSwiZXhwIjoxMzExMjgxOTcwLCJpYXQiOjEzMTEyODA5NzB9
      .IvjKKc54lHvAOCskyEUU8Ou_-8-oXKyFS5bbq-utZPA"
  }
]]></artwork>
          </figure>
        </section>
      </section>
      
      <section anchor="authz-challenge-endpoint">
        <name>Authorization Challenge Endpoint</name>
        
        <t>The authorization challenge endpoint is used by the client to obtain
          an authorization challenge by presenting an MFA token.  The client
          will typically interact directly with the resource owner to obtain an
          authorization grant, which is used as a response to the authorization
          challenge.</t>
        
        <!-- TODO: Clarify this -->
        <t>Use of the authorization challenge endpoint is OPTIONAL; if a client knows of
          a suitable authenticator through an out-of-band mechanism, it can
          obtain a strong authorization grant directly.</t>
        
        <section>
          <name>Authorization Challenge Request</name>
          
          <t>The client makes a request to the authorization challenge endpoint
            by adding the following parameters using the
            <tt>"application/x-www-form-urlencoded"</tt> format with a character
            encoding of UTF-8 in the HTTP request entity-body:</t>
            
          <dl newline="true">
            <dt>mfa_token</dt>
            <dd>REQUIRED. The MFA token received from the authorization server
              in the authorization challenge error response.</dd>
            <!-- TODO: Rename this to challenge_types_supported. -->
            <!-- TODO: Make this case sensitive? -->
            <dt>challenge_type</dt>
            <dd>OPTIONAL. Array of authorization challenge type strings that the
              client supports, expressed as a list of space-delimited,
              case-insensitive strings.</dd>
            <!-- TODO: Clarify this -->
            <dt>authenticator_id</dt>
            <dd>
              OPTIONAL. The identifier of the authenticator to challenge.  The
              authorization server MUST ensure that the authenticator is
              associated with the resource owner.
            </dd>
            <dt>client_id</dt>
            <dd>REQUIRED, if the client is not authenticating with the
              authorization server as described in
              <xref target="RFC6749" section="3.2.1">OAuth 2.0</xref>.</dd>
          </dl>
            
          <t>If the client type is confidential or the client was issued client
            credentials (or assigned other authentication requirements), the
            client MUST authenticate with the authorization server as described
            in <xref target="RFC6749" section="3.2.1">OAuth 2.0</xref>.</t>
          
          <t>For example, the client makes the following HTTP request using
            transport-layer security (with extra line breaks for display
            purposes only):</t>
          
          <figure>
            <artwork><![CDATA[
  POST /challenge HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded

  mfa_token=eyJhbGciOiJ...&challenge_type=otp%20oob
]]></artwork>
          </figure>
          
          <t>The authorization server MUST:</t>
          
          <ul>
            <li>require client authentication for confidential clients or for
              any client that was issued client credentials (or with other
              authentication requirements),</li>
                
            <li>authenticate the client if client authentication is
              included,</li>
            
            <li>ensure that the MFA token was issued to the authenticated
              confidential client, or if the client is public, ensure that the
              token was issued to <tt>"client_id"</tt> in the request,</li>
                
            <li>verify that the MFA token is valid, and</li>
            
            <li>restore the authorization session based on the state referenced
              by or encoded into the MFA token.</li>
          </ul>
        </section>
        
        <section>
          <name>Authorization Challenge Response</name>
          
          <t>If the authorization challenge request is valid and authorized, the
            authorization server selects an authorization challenge, the
            response to which would satisfy the authorization session, and
            constructs the response by adding the following parameters to the
            entity-body of the HTTP response using the <tt>"application/json"</tt>
            format <xref target='RFC8259'/> with a 200 (OK) status code:</t>
          
          <dl newline="true">
            <!-- TODO: Make challenge_type case sensitive, to match grant_type. -->
            <dt>challenge_type</dt>
            <dd>REQUIRED.  The type of the authorization challenge issued.
              Value is case insensitive.</dd>
          </dl>
          
          <t>All additional parameters are specified by the authorization
            challenge type.  This document defines the <tt>"otp"</tt> type in
            <xref target="otp-authz-challenge"/>, the <tt>"oob"</tt> type in
            <xref target="oob-authz-challenge"/>, and the
            <tt>"recovery-code"</tt> type in
            <xref target="recovery-code-authz-challenge"/>.  Other
            specifications may define additional challenge types.</t>
            
          <t>For example:</t>
          <figure>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "challenge_type":"example"
  }
]]></artwork>
          </figure>
          
          <t>If the authorization challenge request failed, the authorization
            server responds with an error response as described in
            <xref target="RFC6749" section="5.2">OAuth 2.0</xref>.</t>
            
          <t>In addition to the error codes defined in
            <xref target="RFC6749" section="5.2">OAuth 2.0</xref>, the following
            error codes are specified for use in authorization challenge
            endpoint responses:</t>
            
          <dl newline="true">
            <!-- TODO: Clarify this -->
            <dt>invalid_authenticator</dt>
            <dd>The requested authenticator does not exist or is not associated
              with the resource owner.</dd>
            <!-- TODO: Rename this to invalid_token to match invalid_grant and invalid_token from bearer scheme -->
            <dt>expired_token</dt>
            <dd>The provided MFA token is invalid, expired, revoked, or was
              issued to another client.  The client MAY initiate a new
              authorization session.</dd>
            <!-- TODO: Rename this to unnegotiable_challenge_type?? -->
            <dt>unsupported_challenge_type</dt>
            <dd>The challenge types supported by the client are not supported by
              the authorization server or not available to the resource owner.</dd>
            <!-- TODO: Clarify this.  Possibly remove as redundant with unnegotiable
               challenge type -->
            <dt>association_required</dt>
            <dd>The resource owner is not associated with any authenticator.
              The authorization session MAY be continued by completing
              authenticator association.</dd>
            <!-- TODO: Move this to a different spec -->
            <dt>server_error</dt>
            <dd>The authorization server encountered an unexpected condition
              that prevented it from fulfilling the request.</dd>
            <!-- TODO: Clarify this, maybe move to another spec -->
            <dt>bad_gateway</dt>
            <dd>The authorization server received an invalid response from
              an upstream server it accessed in attempting to fulfull the
              request.  This typically occurs when challenging an OOB
              authenticator and the gateway is down, for example SMS.</dd>
          </dl>
        </section>
      </section>
    </section>
    
    <section>
      <name>Obtaining Authorization</name>
      
      <section title="OTP Credentials Grant">
        <t>An one-time password is generated by an OTP device, which includes
          hardware devices as well as software-based OTP generators on devices
          such as mobile phones.
        </t>
        
        <section anchor="otp-authz-challenge">
          <name>Authorization Challenge</name>
          
          <t>If the authorization server requires an OTP credential as an
            additional authorization grant, it responds with an OTP
            authorization challenge type containing the following
            parameters:</t>
          
          <dl newline="true">
            <dt>challenge_type</dt>
            <dd>REQUIRED.  Value MUST be set to <tt>"otp"</tt>.</dd>
          </dl>
          
          <t>No additional parameters are specified for the OTP authorization
            challenge type.</t>
            
          <t>For example:</t>
          <figure>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "challenge_type":"otp"
  }
]]></artwork>
          </figure>
        </section>
        
        <section>
          <name>User Interaction</name>
          
          <t>After receiving an OTP challenge, the client prompts or otherwise
            interacts with the resource owner to obtain an OTP generated by a
            device in the possession of the resource owner.</t>
        </section>
        
        <section>
          <name>Access Token Request</name>
          
          <t>The client makes a request to the token endpoint by adding the
            following parameters using the
            <tt>"application/x-www-form-urlencoded"</tt> format with a character
            encoding of UTF-8 in the HTTP request entity-body:</t>
          
          <dl newline="true">
            <dt>grant_type</dt>
            <dd>REQUIRED.  Value MUST be set to
              <tt>"http://auth0.com/oauth/grant-type/mfa-otp"</tt>.</dd>
              
            <dt>otp</dt>
            <dd>REQUIRED.  The one-time password generated by a device.</dd>
            
            <dt>mfa_token</dt>
            <dd>REQUIRED.  The MFA token, <tt>"mfa_token"</tt> from the prior
              authorization challenge error response, defined in 
              <xref target="authorization-challenge-error-response"/>.</dd>
              
            <dt>client_id</dt>
            <dd>REQUIRED, if the client is not authenticating with the
              authorization server as described in
              <xref target="RFC6749" section="3.2.1">OAuth 2.0</xref>.</dd>
          </dl>
          
          <t>If the client type is confidential or the client was issued client
            credentials (or assigned other authentication requirements), the
            client MUST authenticate with the authorization server as described
            in <xref target="RFC6749" section="3.2.1">OAuth 2.0</xref>.</t>
            
          <t>For example, the client makes the following HTTP request using
            transport-layer security (with extra line breaks for display
            purposes only):</t>
        
          <figure>
            <artwork><![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded

  grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp
  &otp=123456&mfa_token=eyJhbGciOiJ...
]]></artwork>
          </figure>
          
          <t>The authorization server MUST:</t>
          
          <ul>
            <li>require client authentication for confidential clients or for
              any client that was issued client credentials (or with other
              authentication requirements),</li>
                
            <li>authenticate the client if client authentication is
              included,</li>
            
            <li>ensure that the MFA token was issued to the authenticated
              confidential client, or if the client is public, ensure that the
              token was issued to <tt>"client_id"</tt> in the request,</li>
                
            <li>verify that the MFA token is valid,</li>
            
            <li>restore the authorization session based on the state referenced
              by or encoded into the MFA token, and</li>
              
            <li>validate the one-time password credentials using its existing
              OTP validation algorithm.</li>
          </ul>
        </section>
        
        <section>
          <name>Access Token Response</name>
          
          <t>If the access token request is valid and authorized, the
            authorization server issues an access token and optional refresh
            token as described in in
            <xref target="RFC6749" section="5.1">OAuth 2.0</xref>.  If the
            request failed client authentication or is invalid, the
            authorization server returns an error response as described in
            <xref target="RFC6749" section="5.2">OAuth 2.0</xref>.</t>
        </section>
      </section>
      
      <section>
        <name>Out-of-Band Authorization Grant</name>
        
        <t>
          An out-of-band verification code is used to obtain authorization via
          an out-of-band authorization ceremony.  Such ceremonys may include
          confirmation via an out-of-band authenticator or multi-party
          authorization.
        </t>
        
        <t>An out-of-band authenticator is a device that can communicate
          securely with the authorization server over a secondary channel,
          such as SMS or push notification.
        </t>
        
        <t>
          Multi-party authorization requires approval from a second authorized
          user, in addition to the resource owner, before an action is allowed
          to take place.
        </t>
        
        <t>
          Out-of-band mechanisms are intentionally open-ended, to allow for
          flexibility in how authorization is obtained.  The details of any
          out-out-band mechanism are beyond the scope of this specification.
        </t>
        
        <section anchor="oob-authz-challenge">
          <name>Authorization Challenge</name>
          
          <t>If the authorization server requires out-of-band authorization as
            an additional authorization grant, it generates a unique out-of-band
            transaction code that is valid for a limited time.  It then
            initiates an out-of-band authorization operation, the details of
            which are out of scope for this specification.  It then responds
            with an OOB authorization challenge type containing the following
            parameters:</t>
          
          <dl newline="true">
            <dt>challenge_type</dt>
            <dd>REQUIRED.  Value MUST be set to <tt>"oob"</tt>.</dd>
            
            <dt>oob_code</dt>
            <dd>REQUIRED.  The out-of-band transaction code.  The out-of-band
              transaction code MUST expire shortly after it is issued to
              mitigate the risk of leaks.  A maximum out-of-band transaction
              code lifetime of 10 minutes is RECOMMENDED.</dd>
              
            <dt>binding_code</dt>
            <dd>OPTIONAL.  The end-user verification code used to bind the
               authorization operation on the secondary channel with the primary
               channel.  REQUIRED, if the value of <tt>"binding_method"</tt>
               is set to <tt>"transfer"</tt> or <tt>"compare"</tt>.</dd>
            
            <dt>binding_method</dt>
            <dd>OPTIONAL.  The method used to bind the authorization operation
              on the secondary channel with the primary channel.  If no value is
              provided, clients MUST use <tt>"none"</tt> as the default.  Values
              defined by this specification are:
              
              <dl newline="true">
                <dt>prompt</dt>
                <dd>The end user should be prompted to enter a code received
                  during out-of-band authorization via the secondary channel
                  into the client.  For example, the end user receives a code on
                  their mobile phone (typically a 6-digit code) and types it
                  into the client.</dd>
                  
                <dt>transfer</dt>
                <dd>The client displays or otherwise communicates the
                  <tt>"binding_code"</tt> to the end user and instructs them
                  to enter it into or otherwise transfer it to the secondary
                  channel.  For example, the end user may view the
                  <tt>"binding_code"</tt> on the client and either type it into
                  an app on their mobile phone or use a QR code to effect the
                  transfer.</dd>
                  
                <dt>compare</dt>
                <dd>The client displays the <tt>"binding_code"</tt> to the end
                  user and instructs them to compare it to the code received
                  during out-of-band authorization before confirming
                  authorization via the secondary channel.</dd>
                  
                <dt>none</dt>
                <dd>No binding is performed between the client on the primary
                  channel and the out-of-band authorization operation via the
                  secondary channel.</dd>
              </dl>
            </dd>
            
            <!-- TODO: Make this required -->
            <dt>expires_in</dt>
            <dd>OPTIONAL.  The lifetime in seconds of the
              <tt>"oob_code"</tt>.</dd>
              
            <dt>interval</dt>
            <dd>OPTIONAL.  The minimum amount of time in seconds that the client
              SHOULD wait between polling requests to the token endpoint.  If no
              value is provided, clients MUST use 5 as the default.</dd>
          </dl>
          
          <t>For example:</t>
          <figure>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "challenge_type":"oob",
    "oob_code":"GmRhmhcxhwAzkoEqiMEg_DnyEysNkuNhszIySk9eS",
    "binding_method":"prompt",
    "expires_in":300,
    "interval":5
  }
]]></artwork>
          </figure>
        </section>
        
        <section>
          <name>User Interaction</name>
          
          <t>After receiving an out-of-band challenge, the client prompts or
            otherwise interacts with the resource owner to inform them of the
            ongoing authorization operation.  Any necessary actions by the
            resource owner or other party on the secondary channel are out of scope
            of this specification.</t>
        </section>
        
        <section>
          <name>Access Token Request</name>
          
          <t>The client makes a request to the token endpoint by adding the
            following parameters using the
            <tt>"application/x-www-form-urlencoded"</tt> format with a character
            encoding of UTF-8 in the HTTP request entity-body:</t>
          
          <dl newline="true">
            <dt>grant_type</dt>
            <dd>REQUIRED.  Value MUST be set to
              <tt>"http://auth0.com/oauth/grant-type/mfa-oob"</tt>.</dd>
              
            <dt>oob_code</dt>
            <dd>REQUIRED.  The out-of-band transaction code, "oob_code" from
              the authorization challenge, defined in
              <xref target="oob-authz-challenge"/>.</dd>
              
            <dt>binding_code</dt>
            <dd>REQUIRED, if the binding method of the authorization challenge
              defined in <xref target="oob-authz-challenge"/>is set to
              <tt>"prompt"</tt>.</dd>
              
            <dt>mfa_token</dt>
            <dd>REQUIRED.  The MFA token, <tt>"mfa_token"</tt> from the prior
              authorization challenge error response, defined in 
              <xref target="authorization-challenge-error-response"/>.</dd>
            
            <dt>client_id</dt>
            <dd>REQUIRED, if the client is not authenticating with the
              authorization server as described in
              <xref target="RFC6749" section="3.2.1">OAuth 2.0</xref>.</dd>
          </dl>
          
          <t>If the client type is confidential or the client was issued client
            credentials (or assigned other authentication requirements), the
            client MUST authenticate with the authorization server as described
            in <xref target="RFC6749" section="3.2.1">OAuth 2.0</xref>.</t>
            
          <t>For example, the client makes the following HTTP request using
            transport-layer security (with extra line breaks for display
            purposes only):</t>
        
          <figure>
            <artwork><![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded

  grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob
  &oob_code=GmRhmhcxhwAzkoEqiMEg_DnyEysNkuNhszIySk9eS
  &binding_code=123456&mfa_token=eyJhbGciOiJ...
]]></artwork>
          </figure>
          
          <t>The authorization server MUST:</t>
          
          <ul>
            <li>require client authentication for confidential clients or for
              any client that was issued client credentials (or with other
              authentication requirements),</li>
                
            <li>authenticate the client if client authentication is
              included,</li>
            
            <li>ensure that the MFA token was issued to the authenticated
              confidential client, or if the client is public, ensure that the
              token was issued to <tt>"client_id"</tt> in the request,</li>
                
            <li>verify that the MFA token is valid,</li>
            
            <li>restore the authorization session based on the state referenced
              by or encoded into the MFA token,</li>
              
            <li>validate the out-of-band transaction code using its existing OOB
              validation algorithm, and</li>
              
            <li>if required, validate the binding code using its existing OOB
              validation algorithm.</li>
          </ul>
        </section>
        
        <section>
          <name>Access Token Response</name>
          
          <t>If the access token request is valid and authorized, the
            authorization server issues an access token and optional refresh
            token as described in in
            <xref target="RFC6749" section="5.1">OAuth 2.0</xref>.  If the
            request failed client authentication or is invalid, the
            authorization server returns an error response as described in
            <xref target="RFC6749" section="5.2">OAuth 2.0</xref>.</t>
            
          <t>In addition to the error codes defined in
            <xref target="RFC6749" section="5.2">OAuth 2.0</xref>, the following
            error codes are specific for the out-of-band authorization grant in
            token endpoint responses:</t>
          
          <dl newline="true">
            <dt>authorization_pending</dt>
            <dd>The authorization request is still pending as the out-of-band
              authorization operation has not yet completed.  The client SHOULD
              repeat the access token request to the token endpoint (a process
              known as polling).  Before each new request, the client MUST wait
              at least the number of seconds specified by the
              <tt>"interval"</tt> parameter of the authorization challenge (see
              <xref target="oob-authz-challenge"/>), or 5 seconds if none was
              provided, and respect any increase in the polling interval
              required by the <tt>"slow_down"</tt> error.</dd>
              
            <dt>slow_down</dt>
            <dd>A variant of <tt>"authorization_pending"</tt>, the authorization
              request is still pending and polling should continue, but the
              interval MUST be increased by 5 seconds for this and all
              subsequent requests.</dd>
              
            <dt>access_denied</dt>
            <dd>The authorization request was denied.</dd>
            
            <dt>expired_token</dt>
            <dd>The <tt>"oob_code"</tt> or <tt>"mfa_token"</tt> has expired, and
              the authorization session has concluded.  The client MAY commence
              a new authorization session but SHOULD wait for user interaction
              before restarting to avoid unnecessary polling.</dd>
          </dl>
          
          <t>The <tt>"authorization_pending"</tt> and <tt>"slow_down"</tt> error
            codes define particularly unique behavior, as they indicate that the
            OAuth client should continue to poll the token endpoint by repeating
            the token request (implementing the precise behavior defined above).
            If the client receives an error response with any other error code,
            it MUST stop polling and SHOULD react accordingly, for example, by
            displaying an error to the user.</t>
          
          <t>On encountering a connection timeout, clients MUST unilaterally
            reduce their polling frequency before retrying.  The use of an
            exponential backoff algorithm to achieve this, such as doubling the
            polling interval on each such connection timeout, is
            RECOMMENDED.</t>
        
          <t>The error codes and client behavior specified in this section are
            intentionally identical to those defined by OAuth 2.0 Device
            Authorization Grant <xref target="RFC8628"/>.</t>
        </section>
      </section>
      
      <section>
        <name>Recovery Code Grant</name>
        
        <t>Recovery codes are a physical or electronic set of secrets shared
          between the resource owner and the authorization server.  Recovery
          codes are typically used in the event another authenticator device
          is lost or malfunctions.
        </t>
        
        <section anchor="recovery-code-authz-challenge">
          <name>Authorization Challenge</name>
          
          <t>If the authorization server requires a recovery code as an
            authorization grant, it responds with a recovery code authorization
            challenge containing the following parameters:</t>
          
          <dl newline="true">
            <dt>challenge_type</dt>
            <dd>REQUIRED.  Value MUST be set to <tt>"recovery-code"</tt>.</dd>
          </dl>
          
          <t>No additional parameters are specified for the recovery code
            authorization challenge type.</t>
            
          <t>For example:</t>
          <figure>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "challenge_type":"recovery-code"
  }
]]></artwork>
          </figure>
        </section>
        
        <section>
          <name>User Interaction</name>
          
          <t>After receiving a recovery code challenge, the client prompts or
            otherwise interacts with the resource owner to obtain a recovery
            code.  Such codes are typically already in the resource owner's
            posession, having been previously distributed to the resource
            owner.</t>
            
          <t>Recovery codes are typically necessary upon the resource owner
            realizing that other authenticators have been lost or are
            malfunctioning (for instance, when attempting to satisfy a
            non-recovery code authorization challenge).  In such an event, the
            client SHOULD provide the resource owner a means of directly
            entering a recovery flow.  Such a flow is end-user initiated, rather
            than authorization server initiated through an authorization
            challenge as described in
            <xref target="recovery-code-authz-challenge"/>.</t>
        </section>
        
        <section>
          <name>Access Token Request</name>
          
          <t>The client makes a request to the token endpoint by adding the
            following parameters using the
            <tt>"application/x-www-form-urlencoded"</tt> format with a character
            encoding of UTF-8 in the HTTP request entity-body:</t>
          
          <dl newline="true">
            <dt>grant_type</dt>
            <dd>REQUIRED.  Value MUST be set to
              <tt>"http://auth0.com/oauth/grant-type/mfa-recovery-code"</tt>.</dd>
              
            <dt>recovery_code</dt>
            <dd>REQUIRED.  The recovery code.</dd>
            
            <dt>mfa_token</dt>
            <dd>REQUIRED.  The MFA token, <tt>"mfa_token"</tt> from the prior
              authorization challenge error response, defined in
              <xref target="authorization-challenge-error-response"/>.</dd>
              
            <dt>client_id</dt>
            <dd>REQUIRED, if the client is not authenticating with the
              authorization server as described in
              <xref target="RFC6749" section="3.2.1">OAuth 2.0</xref>.</dd>
          </dl>
          
          <t>If the client type is confidential or the client was issued client
            credentials (or assigned other authentication requirements), the
            client MUST authenticate with the authorization server as described
            in <xref target="RFC6749" section="3.2.1">OAuth 2.0</xref>.</t>
            
          <t>For example, the client makes the following HTTP request using
            transport-layer security (with extra line breaks for display
            purposes only):</t>
      
          <figure>
            <artwork><![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded

  grant_type=
   http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code
  &recovery_code=WDJB-MJHT&mfa_token=eyJhbGciOiJ...
]]></artwork>
          </figure>
        
          <t>The authorization server MUST:</t>
        
          <ul>
            <li>require client authentication for confidential clients or for
              any client that was issued client credentials (or with other
              authentication requirements),</li>
              
            <li>authenticate the client if client authentication is
              included,</li>
          
            <li>ensure that the MFA token was issued to the authenticated
              confidential client, or if the client is public, ensure that the
              token was issued to <tt>"client_id"</tt> in the request,</li>
              
            <li>verify that the MFA token is valid,</li>
          
            <li>restore the authorization session based on the state referenced
              by or encoded into the MFA token, and</li>
            
            <li>validate the recovery code using its existing recovery code
              validation algorithm.</li>
          </ul>
        </section>
        
        <section title="Access Token Response">
          <t>If the access token request is valid and authorized, the
            authorization server issues an access token and optional refresh
            token as described in in Section 5.1 of <xref target="RFC6749"/>.
            If the request failed client authentication or is invalid, the
            authorization server returns an error response as described in
            Section 5.2 of <xref target="RFC6749"/>.</t>
            
          <t>
            In addition to the parameters defined in Section 5.1 of <xref target="RFC6749"/>,
            the following additional parameters are specific for the recovery
            code grant:
      
            <list style="hanging">
              <t hangText="recovery_code"> <vspace blankLines="1"/>
                OPTIONAL.  A newly issued recovery code, in which case the
                client MUST discard the old recovery code and replace it with
                the new recovery code.</t>
            </list>
          </t>
        </section>
      </section>
      
    </section>
    
    <section title="Discovery Metadata">
      <t>
        Support for the strong authorization flow MAY be declared in the OAuth
        2.0 Authorization Server Metadata <xref target="I-D.ietf-oauth-discovery"/>
        with the following metadata:
      </t>
      <t>
        <list style="hanging">
          <t hangText="mfa_challenge_endpoint">
            <vspace/>
            OPTIONAL.
            URL of the authorization server's MFA challenge endpoint defined in
            <xref target="authz-challenge-endpoint"/>.
          </t>
        </list>
      </t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6749.xml"/>
      <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8259.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-oauth-discovery.xml"/>
    </references>
    <references>
      <name>Informative References</name>
      <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8628.xml"/>
    </references>
  </back>
</rfc>

<!-- TODO: Discuss incorporating user enrollments into challenge response.s -->
